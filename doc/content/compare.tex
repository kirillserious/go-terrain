Ниже приведены времена работы различных версий программы в виде таблиц.
Интересно прослеживается закономерность нелинейного ускорения работы программы для алгоритма Дейкстры в связи с небольшим граничным множеством относительно размера сетки. Так же примерно виден процент времени передачи данных на многонодной установке, относительно времени вычислений.

Приложения запускались на ноутбуке автора с 8 ядерным процессором Intel® Core™ i7-6700HQ и 8 ГиБ ОЗУ.
Многонодная установка состояла из 3 виртуальных машин с 4 ядрами CPU и 8 ГиБ ОЗУ, две из которых использовались для вычислителей. Ноды были взяты у сервиса VK Cloud, который не предоставляет информацию об их физическом расположении и сетевой отдаленности.

\begin{figure}[h]
    \centering
    \begin{tabular}{ | l | l | l | l |}
        \hline
        Размер сетки   & Классический    & Парал. однонодный & Парал. многонодный \\ \hline
        50$\times$50   & 2s              & 700ms             & 2s                 \\
        100$\times$100 & 28s             & 11s               & 24s                \\
        250$\times$250 & 14m 17s         & 4m 56s            & 10m 24s             \\
        500$\times$500 & $\approx$4h 50m & $\approx$1h 20m   & $\approx$2h 40m    \\
        \hline
    \end{tabular}
\caption{Время работы различных реализаций алгоритма Беллмана--Форда.}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{tabular}{ | l | l | l | l |}
        \hline
        Размер сетки     & Классический    & Парал. однонодный & Парал. многонодный \\ \hline
        500$\times$500   & 2.9             & 4.5s              & 19.4s               \\
        1000$\times$1000 & 36s             & 40s               & 3m 20s             \\
        2500$\times$2500 & 10m 40s         & 6m 48s            & 34m 42s            \\
        5000$\times$5000 & $\approx$1h 15m & $\approx$39m      & $\approx$2h 40m    \\
        \hline
    \end{tabular}
    \caption{Время работы различных реализаций алгоритма Дейкстры.}
\end{figure}

Из приведенных выше данных следует, что при небольшом объеме вычислений, параллельные алгоритмы показывают худшие результаты, чем их последовательные аналоги.
Это связано с тем, что на таких объемах значительную роль играет время на синхронизацию потоков, а в случае многонодной установки еще и время, затрачиваемое на передачу информации по сети.

Затем, при увеличении размеров сетки, параллельные алгоритмы становятся более эффективны. Алгоритм, большая часть которого распараллелена, показывает большее отставание от однопоточного. При этом видно, что увеличением вычислительных мощностей нельзя догнать произвоителность алгоритма, с априори меньшей алгоритмической сложностью. Хотя многонодные алгоритмы не оправдали, возложенных ни них надежд.