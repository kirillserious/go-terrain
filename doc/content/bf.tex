Данный раздел содержит описание алгоритма Беллмана--Форда в применении к нашей задачи, а также в процессе описаны общие принципы работы построенных алгоритмов, которые будут использованы и в дальнейшем.

Традиционно для алгоритмов данного типа (алгоритм поиска кратчайшего пути) маркирование узлов сетки предполагаемым оптимальным значением функционала.
Маркировка одного и того же узла может происходить один или несколько раз, но в результате работы программы маркировки каждой вершины должны соответствовать оптимальному значению функционала качества для данной вершины.
Поэтому далее мы будем обозначать маркировку как $V(i, j)$, а перемаркирование как $V(i, j) \leftarrowtail v$.
Изначально предполагается, что все вершины, кроме целевой, имеют маркировку $+\infty$. Целевая же вершина $(i_1, j_1)$ имеет маркировку $0$.

Ниже приведено описание алгоритма:

\begin{enumerate}
    \item Необходимо провести $(NM - 1)$ итерации алгоритма.
    \item На каждой итерации происходит полный проход по сетке. Далее $(i,j)$ --- позиция при проходе.
    \item Для каждой вершины из возможного множества $(\hat i, \hat j) \in \mathrm{possible}(i,j)$ происходит перемаркировка: в случае, если $V(i, j) > d_{i,j}(\hat i, \hat j) + V(\hat i, \hat j)$, перемаркируем
    \[
        V(i,j) \leftarrowtail d_{i,j}(\hat i, \hat j) + V(\hat i, \hat j).
    \]
\end{enumerate}

Заметим, что оптимальная траектория не может иметь более $(NM - 1)$ перемещения. Таким образом алгоритм действительно ищет кратчайший путь.

\subsection{Распараллеливание на CPU}
Ядра центрального процессора~--- это высокопроизводительные процессоры, которые есть в каждом компьютере. В стандартном персональном компьютере от 4 до 16 ядер. Пусть на компьютере имеется $C$ ядер.

Предлагается распараллелить проход по сетке по переменной $i$. Разобьем сетку на $(C-1)$ штуку размером $\left\lfloor \frac{N}{C}\right\rfloor \times M$ и одну размера $N-(C-1)\left\lfloor \frac{N}{C} \right\rfloor \times M$. Каждое ядро должно обрабатывать собственную матрицу.

Возникающую проблему синхронизации процессов при обработке соседних подматриц предлагается решать массивом мьютексов~---примитивов синхронизации, обеспечивающих взаимное исключение исполнения критических участков кода.

Перед началом основной программы каждый мьютекс из массива $A$ размера $C$ переводится в закрытое состояние. По окончании обработки $c \in \{0,\ldots,C-1\}$ процессом первой строки процесс переводит мьютекс $A_{c}$ в открытое состояние. Перед началом обработки последней строки процесс $c$ дожидается открытия мьютекса $A_{c+1}$, если $c+1<C$.

\subsection{Распараллелевание на GPU}
Параллельные вычисления на графическом процессоре в последние годы очень активно развиваются. Это связано с типичной архитектурой таких процессоров: это большое количество маломощных процессоров с общей памятью. Почти всегда такие вычисления используются для майнинга криптовалюты.

На сегодняшний стандартной архитектурой для написания программ на GPU является CUDA SDK, поддерживаемая исключительно графическими картами компании Nvidia. Ввиду отсутствия данного графического процессора, мы ограничимся лишь описанием алгоритма, в сравнении времени работы программ данный алгоритм принимать участие не будет.

Предлагается вместо одного прохода по сетке на каждой итерации, проходить 8 раз (по числу максимальной мощности возможного множества). При этом каждый узел при таком проходе будет обработан параллельно. На каждом из восьми проходов будет обработано только одно возможное направление движения, причем у всех узлов оно должно совпадать. Таким образом мы обеспечиваем синхронизацию.

\subsection{Распараллеливание на многонодной установке}
Предлагается использовать модель \textit{master-follower}. Пусть имеется одна \textit{master} нода, с которой осуществляется оркестрация установки, и $L$ \textit{follower} нод с $C_l, l=\overline{1,L}$ доступных ядер процессора, используемых непосредственно для вычислений. Предполагается, что между нодами настроена сеть и известны адреса всех сервисов.

Программа поставляется в виде http-сервиса вычислителя, и основной программы, которая общается с вычислителями посредством http запросов. На \textit{follower} нодах запускаются сервисы вычислителя в количестве, соответствующим количеству доступных ядер процессора.

Параллелелизм осуществляется как и в случае распараллелевания на CPU. Но из-за отсутствия общей памяти возникает проблема синхронизации данных между всеми вычислителями. Для этого по результатам обработки основная программа должна передать вычислителям минимальное инкрементальное изменение состояния для данного вычислителя. Для этого последняя строка каждого батча считается основной программой еще один раз, после чего эта строка отправлется вычислителю для синхронизации.